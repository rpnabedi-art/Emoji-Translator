'-----------------------------------------------------------------------------------------
'name                     : i2c_pcf8574.bas
'copyright                : (c) 1995-2005, MCS Electronics
'purpose                  : shows how you could use the I2C slave library to create a PCF8574
'micro                    : AT90S2313
'suited for demo          : NO, ADDON NEEDED
'commercial addon needed  : yes
'-----------------------------------------------------------------------------------------

$regfile = "2313def.dat"                                    ' specify the used micro
$crystal = 3684000                                          ' used crystal frequency
$baud = 19200                                               ' use baud rate
$hwstack = 32                                               ' default use 32 for the hardware stack
$swstack = 32                                               ' default use 32for the SW stack
$framesize = 40                                             ' default use 40 for the frame space

'This program shows how you could use the I2C slave library to create a PCF8574
'The PCF8574 is an IO extender chip that has 8 pins.
'The pins can be set to a logic level by writing the address followed by a value
'In order to read from the pins you need to make them '1' first

'This program uses a AT90S2313, PORTB is used as the PCF8574 PORT
'The slave library needs INT0 and TIMER0 in order to work.
'SCL is PORTD.4 (T0)
'SDA is PORTD.2 (INT0)
'Use 10K pull up resistors for both SCL and SDA

'The Slave library will only work for chips that have T0 and INT0 connected to the same PORT.
'These chips are : 2313,2323, 2333,2343,4433,tiny22, tiny12,tiny15, M8
'The other chips have build in hardware I2C(slave) support.

'specify the slave address. This is &H40 for the PCF8574
'You always need to specify the address used for write. In this case &H40 ,

'The config i2cslave command will enable the global interrupt enable flag !
Config I2cslave = &B01000000                                ' same as &H40
'Config I2cslave = &H40 , Int = Int0 , Timer = Timer0
'A byte named _i2c_slave_address_received is generated by the compiler.
'This byte will hold the received address.

'A byte named _i2c_slave_address is generated by the compiler.
'This byte must be assigned with the slave address of your choice

'the following constants will be created that are used by the slave library:

' _i2c_pinmask = &H14
' _i2c_slave_port = Portd
' _i2c_slave_pin = Pind
' _i2c_slave_ddr = Ddrd
' _i2c_slave_scl = 4
' _i2c_slave_sda = 2

'These values are adjusted automatic depending on the selected chip.
'You do not need to worry about it, only provided as additional info

'by default the PCF8574 port is set to input
Config Portb = Input
Portb = 255                                                 'all pins high by default

'DIM a byte that is not needed but shows how you can store/write the I2C DATA
Dim Bfake As Byte


'empty loop
 Do
   ' you could put your other program code here
   'In any case, do not use END since it will disable interrupts

 Loop


'here you can write your other program code
'But do not forget, do not use END. Use STOP when needed

'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'             The following labels are called from the slave library
'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

'When the master wants to read a byte, the following label is allways called
'You must put the data you want to send to the master in variable _a1 which is register R16
I2c_master_needs_data:
  'when your code is short, you need to put in a waitms statement
  'Take in mind that during this routine, a wait state is active and the master will wait
  'After the return, the waitstate is ended
  Config Portb = Input                                      ' make it an input
  _a1 = Pinb                                                ' Get input from portB and assign it
Return


'When the master writes a byte, the following label is always called
'It is your task to retrieve variable _A1 and do something with it
'_A1 is register R16 that could be destroyed/altered by BASIC statements
'For that reason it is important that you first save this variable

I2c_master_has_data:
  'when your code is short, you need to put in a waitms statement
  'Take in mind that during this routine, a wait state is active and the master will wait
  'After the return, the waitstate is ended

  Bfake = R16                                               ' this is not needed but it shows how you can store _A1 in a byte
  'after you have stored the received data into bFake, you can alter R16
  Config Portb = Output                                     ' make it an output since it could be an input
  Portb = r16                                               'assign _A1 (R16)
Return


'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

'You could simply extend this sample so it will use 3 pins of PORT D for the address selection
'For example portD.1 , portd.2 and portD.3 could be used for the address selection
'Then after the CONFIG I2CSLAVE = &H40 statement, you can put code like:
'Dim switches as Byte   ' dim byte
'switches = PIND        ' get dip switch value
'switches = switches and &H1110 ' we only need the lower nibble without the LS bit
'_i2c_slave_address = &H40 + switches ' set the proper address